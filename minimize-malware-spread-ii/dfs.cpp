/*
https://zhanghuimeng.github.io/post/leetcode-928-minimize-malware-spread-ii/
Runtime: 208 ms, faster than 23.68% of C++ online submissions for Minimize Malware Spread II.

*/
class Solution {
private:
    void dfs(int cur, const int& x, vector<vector<int>>& graph, bool isRemoved[], unordered_set<int> affect[]) {
        for (int i = 0; i < graph.size(); i++) {
            if (graph[cur][i] && !isRemoved[i] && affect[x].find(i) == affect[x].end()) {
                affect[x].insert(i);
                dfs(i, x, graph, isRemoved, affect);
            }
        }
    }

public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        bool isRemoved[n];
        memset(isRemoved, 0, sizeof(isRemoved));
        for (int x: initial)
            isRemoved[x] = true;

        // 分别DFS
        unordered_set<int> affect[n];
        for (int x: initial) {
            isRemoved[x] = false;
            affect[x].insert(x);
            dfs(x, x, graph, isRemoved, affect);
            isRemoved[x] = true;
        }

        // 每个结点会被哪些结点感染
        unordered_set<int> affectedBy[n];
        for (int i = 0; i < n; i++) {
            for (int x: affect[i])
                affectedBy[x].insert(i);
        }

        // 只被一个结点感染的结点
        int singleCnt[n];
        memset(singleCnt, 0, sizeof(singleCnt));
        for (int i = 0; i < n; i++) {
            if (!isRemoved[i] && affectedBy[i].size() == 1)
                singleCnt[*affectedBy[i].begin()]++;
        }

        // 取最大值
        int index = -1, maximum = -1;
        for (int i = 0; i < n; i++) {
            if (isRemoved[i] && singleCnt[i] > maximum) {
                index = i;
                maximum = singleCnt[i];
            }
        }

        return index;
    }
};
